
# 자바에서의 객체 특징

- 캡슐화
- 추상화
- 다형성
- 상속성

<hr>


# 상속

- 상속 정의

```markdown
다른 클래스(부모클래스=상위클래스)가 가지고 있는 멤버(필드, 메소드)들을

새로 작성할 클래스에서 직접 만들지 않고 상속을 받음으로써

새 클래스(자식클래스= 하위클래스)가 자신의 멤버처럼 사용할 수 있는 기능
```

- 상속의 장점
  - <strong>적은양의 코드</strong>로 새로운 클래스를 작성 할 수 있다.
  - 코드를 공통적으로 관리하기 때문에 <strong>코드 추가 및 변경하는데 좋다</strong>
  - 코드의 중복을 제거하여 프로그램의 <strong>생산성/유지 보수</strong>에 크게 기여한다.


- 상속의 특징
  - <strong>모든 클래스는 Object 클래스의 후손</strong>
    - Object클래스가 제공하는 메소드를 오버라이딩하여 메소드 재구현 가능
    
  - 부모클래스의 생성자, 초기화 블록은 상속이 안된다.
    - 자식클래스 생성할 때 부모 클래스 생성자 먼저 실행
    - 자식클래스 생성자 안에 <strong>부모 클래스 생성자를 호출하고 싶으면 super사용</strong>
    
  - 부모의 private멤버는 상속이 되지만, 직접 접근이 불가능하다.
    - 부모클래스 자체가 아니기 때문에 private 멤버는 자식클래스에서 직접 접근이 불가능하다.
    - super()를 이용하여 전달받은 부모 필드값을 부모생성자쪽으로 넘기거나
    - setter(), getter() 메소드를 이용하여 접근할 수 있다.

- 상속 : extends 키워드를 붙여야한다.
```java

// [접근제한자] class 자식클래스명 extends 부모클래스명{ ... }

// 예시
public class Academy extends Company{
              ....
}
```

<hr>


- this와 super
  - this
    - 자기 자신에 포커스
    - this 
      - 객체 자신의 주소를 저장하고 있는 참조변수
      
    - this() 
      - 다른 생성자를 불러와서, 코드 중복을 방지.
      
      
  - super
    - 나의 부모에 포커스
    - super.멤버
      - 부모클래스의 주소값을 갖고있는 참조변수 
      - 부모가 갖고있는 멤버(메소드, 필드)를 불러올 수 있다. 
      
    - suepr(): 부모 생성자
      - 부모 생성자를 호출하는 메소드
      - 후손 생성자에 부모 생성자가 포함되어있다.
      - 자식객체를 생성하기 전에, 먼저 부모생성자가 super() 호출된다. (즉, 자식생성자 맨처음에 부모생성자super() 가 있어야한다.)
        - 자식객체 생성자안에 실제로 super()가 내재되어있다.
          - 왜냐면 부모가 있어야 자식이 나오기때문이다.

<hr>

# 오버라이딩
- 정의
  - <strong> 자식클래스(하위클래스)에서 부모로부터 물려받은 메소드를 재정의 = 재작성</strong>
  - <string>부모로부터 상속받은 메소드를 재작성/ 재정의</string>하는 것
  - 부모가 제공하는 기능을 고쳐서 사용한다.
  
- 특징
  - 메소드 헤드라인 위에 반드시 ```@Override``` 를 표시한다.

- 성립조건
  - 부모클래스로부터 상속받은 메소드 이름과 동일해야한다.
  - <strong>```매개변수 개수```, ```매개변수 타입```, ```매개변수 순서```, ```리턴타입```이 동일</strong>해야한다.
  - private 는 오버라이딩 불가능하다.
  - `접근제한자`는 부모클래스보다 접근범위가 넓다면 변경할 수 있다.
  
  <br>
  
  - final 예약어
    - final 메소드는 오버라이딩 불가능하다. (더이상의 수정이 없다)
      - 파이널 메소드는 정의하지 않고 그대로 사용할 수 있다. 재정의를 못한다.
      - final 예약어는 변수/ 메소드 / 클래스 에 붙일 수 있다.
      - 변수에 final => 더이상 값 수정 안됨 => 상수
      - 메소드에 final => 더이상 수정안됨 => 더이상의 오버라이딩 안됨.(자식클래스에서의 재정의 안됨)
      - 클래스에 final => '상속'을 할 수 없다. (더이상 확장을 할 수 없다.)
        - 클래스에 abstract와 final을 동시에 사용 불가능 => 성격이 아주 정반대.
        - final은 더이상 수정할 수 없음
        - abstract는 하위클래스에 메소드를 재정의해야한다.
          - abstract => 미완성 => 상속을 해야하며 재정의를 통해서 완성을 시켜야한다.
      - abstract(변경이 필요), final(변경불가) 동시에 사용할 수 없다.
      - static(공유)와 abstract(미완성=변경필요->객체마다 구체화가 필요) 동시에 사용 불가능
      - abstract메소드의 접근제한자로 private불가능 -> 그러면 하위클래스(구체화클래스)에서 메소드를 재정의 할 수 없음.
<br>

- 오버로딩(Over loading)
  - <string>같은 클래스 내에서 이름이 같은 메소드를 여러 개를 만들 수 있는 것</string>을 의미한다.
  - 생성자/ 메소드 모두 여러개로 만들 수 있다.
  - 메소드의 매개변수의 `개수/ 타입 / 순서`가 다르면 오버로딩이 가능하다.
  - 리턴타입이 달라도 상관없다.
  

